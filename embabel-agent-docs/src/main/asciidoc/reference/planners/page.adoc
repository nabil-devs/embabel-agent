[[reference.planners]]
=== Choosing a Planner

Embabel supports multiple planning strategies.
All are deterministic, but their behaviour differs--although it is always predictable.

All planning strategies are entirely typesafe in Java or Kotlin.

The planning strategies currently supported out of the box are:

[cols="1,2,3",options="header"]
|===
|Planner |Best For |Description

|*GOAP* (default)
|Business processes with defined outputs
|Goal-oriented, deterministic planning. Plans a path from current state to goal using preconditions and effects.

|*Utility*
|Exploration and event-driven systems
|Selects the highest-value available action at each step. Ideal when you don't know the outcome upfront.
|===

TIP: Both planners support *nested workflows*--any action can return a `Workflow<O>` class to enter a nested flow.
Utility AI also supports the `@Subflow` annotation and `@Agent`-annotated classes for nesting without specifying output types.
Nested workflows are good for looping behaviors, multi-phase processes, and sub-workflows with their own planning.

As most of the documentation covers GOAP, this section discusses the alternative planners and nested workflows.

[[reference.planners__utility]]
==== Utility AI

https://en.wikipedia.org/wiki/Utility_system[Utility AI] selects the action with the highest _net value_ from all available actions at each step.
Unlike GOAP, which plans a path to a goal, Utility AI makes greedy decisions based on immediate value.

Utility AI excels in *exploratory scenarios* where you don't know exactly what you want to achieve.
Consider a GitHub issue triage system: when a new issue arrives, you don't have a predetermined goal.
Instead, you want to react appropriately based on the issue's characteristics--maybe label it, maybe respond, maybe escalate.
The "right" action depends on what you discover as you process it.

This makes Utility AI ideal for scenarios where:

* There is no clear end goal--you're exploring possibilities
* Multiple actions could be valuable depending on context
* You want to respond to changing conditions as they emerge
* The best outcome isn't known upfront

===== When to Use Utility AI

* *Event-driven systems*: React to incoming events (issues, stars, webhooks) with the most appropriate action
* *Chatbots*: Where the platform provides multiple response options and selects the best one
* *Exploration*: When you want to discover what's possible rather than achieve a specific goal

===== Using Utility AI with `@EmbabelComponent`

For Utility AI, actions are typically provided via `@EmbabelComponent` rather than `@Agent`.
This allows the _platform_ to select actions across multiple components based on utility, rather than constraining actions to a single agent.

Here's an example from the Shepherd project that reacts to GitHub events:

[source,kotlin]
----
@EmbabelComponent  // <1>
class IssueActions(
    val properties: ShepherdProperties,
    private val communityDataManager: CommunityDataManager,
    private val gitHubUpdater: GitHubUpdater,
) {

    @Action(outputBinding = "ghIssue")  // <2>
    fun saveNewIssue(ghIssue: GHIssue, context: OperationContext): GHIssue? {
        val existing = communityDataManager.findIssueByGithubId(ghIssue.id)
        if (existing == null) {
            val issueEntityStatus = communityDataManager.saveAndExpandIssue(ghIssue)
            context += issueEntityStatus  // <3>
            return ghIssue
        }
        return null  // <4>
    }

    @Action(
        pre = ["spel:newEntity.newEntities.?[#this instanceof T(com.embabel.shepherd.domain.Issue)].size() > 0"]  // <5>
    )
    fun reactToNewIssue(
        ghIssue: GHIssue,
        newEntity: NewEntity<*>,
        ai: Ai
    ): IssueAssessment {
        return ai
            .withLlm(properties.triageLlm)
            .creating(IssueAssessment::class.java)
            .fromTemplate("first_issue_response", mapOf("issue" to ghIssue))  // <6>
    }

    @Action(pre = ["spel:issueAssessment.urgency > 0.0"])  // <7>
    fun heavyHitterIssue(issue: GHIssue, issueAssessment: IssueAssessment) {
        // Take action on high-urgency issues
    }
}
----

<1> `@EmbabelComponent` contributes actions to the platform, not a specific agent
<2> `outputBinding` names the result for later actions to reference
<3> Add entity status to context, making it available to subsequent actions
<4> Returning `null` prevents further actions from firing for this issue
<5> SpEL precondition: only fire if new issues were created
<6> Use AI to assess the issue via a template
<7> This action only fires if the assessment shows urgency > 0

The platform selects which action to run based on:

1. Which preconditions are satisfied (type availability + SpEL conditions)
2. The `cost` and `value` parameters on `@Action` (net value = value - cost)

===== Action Cost and Value

The `@Action` annotation supports `cost` and `value` parameters (both 0.0 to 1.0):

[source,kotlin]
----
@Action(
    cost = 0.1,   // <1>
    value = 0.8   // <2>
)
fun highValueAction(input: Input): Output {
    // Action implementation
}
----

<1> Cost to execute (0.0 to 1.0) - lower is cheaper
<2> Value when executed (0.0 to 1.0) - higher is more valuable

The Utility planner calculates _net value_ as `value - cost` and selects the action with the highest net value from all available actions.

===== The Nirvana Goal

Utility AI supports a special "Nirvana" goal that is never satisfied.
This keeps the process running, continuously selecting the highest-value available action until no actions are available.

===== Extensibility

Utility AI fosters extensibility.
For example, multiple groups within an organization can contribute their own `@EmbabelComponent` classes with actions that bring their own expertise to enhance behaviours around shared types, while retaining the ability to own and control their own extended model.

[[reference.planners__workflows]]
==== Nested Workflows

Nested workflows provide explicit sub-processes within any agent.
*Any action can enter a nested workflow by returning an `@Agentic` class (such as `@Agent` or `@Subflow`) with a single goal.*
This works with both GOAP and Utility planners--there is no separate "state machine planner."

Unlike LangGraph, Embabel workflows are fully typesafe and enjoy the benefits of GOAP planning within each workflow.

===== When to Use Nested Workflows

* *Workflows with loops*: Human-in-the-loop feedback cycles, retry logic
* *Multi-phase processes*: Where each phase has distinct actions and data
* *Complex branching*: Where different paths lead to different terminal states
* *Contained sub-workflows*: Localized stateful behavior within a larger workflow

===== How Nested Workflows Work

The key insight is simple: **returning an `@Agentic` class from an action enters that workflow as a nested agent.**

For GOAP planning, the nested class must have exactly one business goal (defined via `@AchievesGoal`) so the planner knows the output type.
For Utility AI planning, any `@Agentic` class with actions can be nested.

1. When an action returns an `@Agentic` class instance (e.g., `@Subflow` or `@Agent`), the process enters that workflow
2. The goal's output type (from `@AchievesGoal`) tells the planner what type the workflow produces
3. Within each workflow, the planner selects which action to execute based on preconditions and effects
4. When an action with `@AchievesGoal` completes, the workflow finishes and returns its result
5. The workflow's result replaces the workflow object on the parent's blackboard

===== Example: Write and Review Workflow

This example shows a workflow with nested phases for reviewing and revising a story:

[source,kotlin]
----
@Agent(description = "Write and review story with human feedback loop")
class WriteAndReviewAgent {

    // Common interface for all workflow phases
    interface StoryFlow : Workflow<Story> {  // <1>
        override val outputType: Class<Story>
            get() = Story::class.java
    }

    @Action
    fun writeStory(input: UserInput): Reviewing {  // <2>
        val story = Story("A story about: ${input.content}")
        return Reviewing(story)
    }

    class Reviewing(val story: Story) : StoryFlow {  // <3>

        @Action
        fun collectFeedback(): HumanFeedback {
            // In real usage, this would use WaitFor.formSubmission(...)
            return HumanFeedback(approved = false, comments = "Needs more detail")
        }

        @Action
        fun assessFeedback(feedback: HumanFeedback): Assessment {
            return Assessment(
                story = story,
                feedback = feedback,
                accepted = feedback.approved,
                suggestions = if (feedback.approved) emptyList() else listOf("Add more detail"),
            )
        }

        @Action
        fun decide(assessment: Assessment): StoryFlow {  // <4>
            return if (assessment.accepted) {
                Done(assessment.story, assessment.feedback)
            } else {
                Revising(assessment.story, assessment)
            }
        }
    }

    class Revising(val story: Story, val assessment: Assessment) : StoryFlow {

        @Action
        fun improveStory(): Reviewing {  // <5>
            val improvedStory = Story("${story.text} [Improved based on: ${assessment.suggestions}]")
            return Reviewing(improvedStory)
        }
    }

    class Done(val story: Story, val feedback: HumanFeedback) : StoryFlow {

        @Action
        @AchievesGoal(description = "Story reviewed and accepted")  // <6>
        fun publish(): ReviewedStory {
            return ReviewedStory(story, feedback)
        }
    }
}
----

<1> Common interface extends `Workflow<Story>` with the `outputType` property
<2> Entry action returns a workflow class to enter the reviewing phase
<3> Workflow classes hold state in constructor parameters
<4> Actions can return other workflow classes to transition between phases
<5> Returning `Reviewing` creates a loop back to the review phase
<6> `@AchievesGoal` marks the terminal action that produces the workflow's result

This enables complex workflow patterns:

* **Draft → Review → (Revise → Review)* → Done**: Loop until approved
* **Processing → (Success | Failure)**: Branch to different terminal outcomes
* **Multi-step GOAP within workflows**: Multiple actions planned by GOAP before transitioning

===== The Workflow Interface

Workflow classes must implement the `Workflow<O>` interface:

[source,kotlin]
----
interface Workflow<OUTPUT> {
    val outputType: Class<OUTPUT>
}
----

The `outputType` property tells GOAP what type this workflow produces.
This is necessary because Java type erasure would otherwise hide the generic type at runtime.

===== Workflow Class Options

Workflows can be nested classes (static) or inner classes:

[source,kotlin]
----
// Nested class (static) - no access to enclosing agent instance
class ProcessingWorkflow(val data: String) : Workflow<Result> {  // <1>
    override val outputType = Result::class.java

    @Action
    @AchievesGoal(description = "Process complete")
    fun process(): Result = Result(data.uppercase())
}

// Inner class - has access to enclosing agent instance (can use injected services)
inner class ProcessingWorkflow(val data: String) : Workflow<Result> {  // <2>
    override val outputType = Result::class.java

    @Action
    @AchievesGoal(description = "Process complete")
    fun process(): Result = Result(data.uppercase())
}
----

<1> Nested (static) class - fully self-contained, no access to enclosing instance
<2> Inner class - has access to enclosing agent instance and its injected dependencies

WARNING: **Inner classes and persistence**: Inner classes (declared with the `inner` keyword in Kotlin) hold a reference to their enclosing instance.
This can cause issues with workflow persistence/serialization because the entire enclosing object graph must also be serialized.
*Prefer nested (static) classes for workflows* unless you specifically need access to injected services from the enclosing agent.
The runtime will log a warning when an inner class workflow is detected.

===== Data Encapsulation in Workflows

Workflows hold their state in constructor parameters.
This captures context when entering the workflow:

[source,kotlin]
----
class ReviewingWorkflow(
    val story: Story,  // <1>
    val reviewer: Reviewer,  // <2>
) : FlowReturning<ReviewedStory> {
    override val outputType = ReviewedStory::class.java

    @Action
    @AchievesGoal(description = "Review complete")
    fun review(): ReviewedStory {
        // Both story and reviewer are available here
        return ReviewedStory(story, reviewer.review(story))
    }
}
----

<1> The story to be reviewed - captured when entering the workflow
<2> Additional context passed to the workflow

===== Interface Hierarchies

Using a common interface for related workflow classes enables type-safe transitions:

[source,kotlin]
----
interface StoryFlow : FlowReturning<Story> {
    override val outputType: Class<Story>
        get() = Story::class.java
}

class Reviewing(val story: Story) : StoryFlow { ... }
class Revising(val story: Story) : StoryFlow { ... }
class Done(val story: Story) : StoryFlow { ... }
----

Actions can return the interface type to allow any of the implementing workflow classes:

[source,kotlin]
----
@Action
fun decide(assessment: Assessment): StoryFlow {  // Returns interface type
    return if (assessment.accepted) Done(...) else Revising(...)
}
----

[[reference.planners__subflow]]
===== @Subflow and @Agent for Nested Workflows

Any `@Agentic` class (including `@Subflow` and `@Agent`) can be used as a nested workflow.
The key requirement for GOAP planning is that the class has **exactly one business goal** (via `@AchievesGoal`), which tells the planner what output type to expect.

[source,kotlin]
----
@Subflow  // <1>
class ProcessingPhase(val data: String) {

    @Action
    @AchievesGoal(description = "Process the data")  // <2>
    fun process(): ProcessedData {
        return ProcessedData(data.uppercase())
    }
}
----

<1> `@Subflow` marks this class as agentic (can be run as nested agent)
<2> Single `@AchievesGoal` enables use with both GOAP and Utility planners

====== Planner Support for Nested Classes

[cols="1,2,2",options="header"]
|===
|Type |GOAP Support |Utility Support

|`@Subflow` with single goal
|Yes - output type inferred from goal
|Yes

|`@Subflow` with multiple goals
|No - ambiguous output type
|Yes

|`@Agent` with single goal
|Yes - output type inferred from goal
|Yes

|`@Agent` with multiple goals
|No - ambiguous output type
|Yes

|`FlowReturning<O>` (legacy)
|Yes - output type explicit
|Yes
|===

TIP: For GOAP compatibility, ensure your nested class has exactly one `@AchievesGoal` annotation.
Utility AI is more flexible and works with any number of goals.

====== Example: @Subflow with Utility AI

[source,kotlin]
----
// Simple @Subflow - no output type needed
@Subflow
class ProcessingPhase(val data: String) {  // <1>

    @Action
    @AchievesGoal(description = "Process data")  // <2>
    fun process(): ProcessedData {
        return ProcessedData(data.uppercase())
    }
}

@Agent(description = "Utility agent with @Subflow", planner = PlannerType.UTILITY)
class DataProcessor {

    @Action
    fun startProcessing(input: UserInput): ProcessingPhase {  // <3>
        return ProcessingPhase(input.content)
    }
}
----

<1> `@Subflow` is simpler than `FlowReturning<O>` - no `outputType` property needed
<2> Still use `@AchievesGoal` to mark terminal actions
<3> Returning a `@Subflow` from an action enters it as a nested agent (Utility AI only)

====== @Subflow Chaining

@Subflow instances can return other @Subflow instances, enabling multi-phase processing:

[source,kotlin]
----
@Subflow
class ValidationPhase(val data: String) {

    @Action
    @AchievesGoal(description = "Validate and proceed")
    fun validate(): ProcessingPhase {  // <1>
        // Validation logic...
        return ProcessingPhase(data)
    }
}

@Subflow
class ProcessingPhase(val data: String) {

    @Action
    @AchievesGoal(description = "Process complete")
    fun process(): Result {
        return Result(data.processed())
    }
}
----

<1> Returning another `@Subflow` chains to the next phase

[[reference.planners__nested_agents]]
===== @Agent Classes as Nested Agents

Since `@Agent` is meta-annotated with `@Agentic`, any `@Agent` class can be returned from actions.
With a single goal, it works with both GOAP and Utility planners.
This enables injecting agents as dependencies and delegating work to them.

[source,kotlin]
----
@Agent(description = "Text processor agent")
class TextProcessorAgent {  // <1>

    @Action
    @AchievesGoal(description = "Process text")  // <2>
    fun process(input: UserInput): ProcessedText = ProcessedText(input.content.uppercase())
}

@Agent(description = "Orchestrator agent")  // <3>
class OrchestratorAgent {

    @Action
    @AchievesGoal(description = "Delegate and process")
    fun delegateProcessing(input: UserInput): TextProcessorAgent {  // <4>
        return TextProcessorAgent()
    }
}
----

<1> The nested `@Agent` class has its own actions and goals
<2> Single goal enables GOAP compatibility
<3> Works with GOAP (default) because nested agent has single goal
<4> Returning an `@Agent` instance runs it as a nested agent

====== Chaining Nested Types

Nested @Agent classes, @Subflow classes, and FlowReturning instances can chain to each other:

[source,kotlin]
----
@Agent(description = "Multi-phase processor", planner = PlannerType.UTILITY)
class MultiPhaseAgent {

    @Action
    fun startWithAgent(input: UserInput): ValidatorAgent {  // <1>
        return ValidatorAgent()
    }
}

@Agent(description = "Validator")
class ValidatorAgent {

    @Action
    @AchievesGoal(description = "Validate and proceed")
    fun validate(input: UserInput): ProcessingSubflow {  // <2>
        return ProcessingSubflow(input.content)
    }
}

@Subflow
class ProcessingSubflow(val data: String) {

    @Action
    @AchievesGoal(description = "Process complete")
    fun process(): Result = Result(data.processed())
}
----

<1> Start by delegating to an `@Agent` class
<2> The `@Agent` can return a `@Subflow` to continue processing

IMPORTANT: For GOAP planning, nested `@Subflow` and `@Agent` classes must have exactly one business goal (via `@AchievesGoal`).
Classes with multiple goals can only be nested when using the Utility planner, which doesn't need a predetermined output type.

[[reference.planners__programmatic_agents]]
===== Programmatic Agents as Nested Agents

Programmatically created agents using `SimpleAgentBuilder`, `RepeatUntilBuilder`, or other DSL builders can be returned from actions and run as nested agents.
This enables dynamic agent composition where the nested agent's structure is determined at runtime.

The same rules apply to programmatic agents as to annotated classes:

* *GOAP*: Requires exactly one goal to determine the output type
* *Utility AI*: Works with any number of goals

====== Using SimpleAgentBuilder

`SimpleAgentBuilder` is the simplest way to create a programmatic agent:

[source,kotlin]
----
// Create a simple processor using SimpleAgentBuilder
fun createSimpleProcessor(): AgentScope {
    return SimpleAgentBuilder<ProcessedData>()  // <1>
        .consuming(UserInput::class.java)       // <2>
        .running { ctx ->                       // <3>
            ProcessedData("processed: ${ctx.input.content}")
        }
        .build()
        .build()
}

// Agent that returns a programmatic agent
@Agent(description = "Orchestrator")
class Orchestrator {

    @Action
    @AchievesGoal(description = "Delegate to programmatic agent")
    fun delegate(input: UserInput): AgentScope {  // <4>
        return createSimpleProcessor()
    }
}
----

<1> Specify the result type
<2> Specify the input type the agent consumes
<3> Define the action logic
<4> Returning an `AgentScope` from an action runs it as a nested agent

====== Using RepeatUntilBuilder for Loops

`RepeatUntilBuilder` creates agents with feedback loops:

[source,kotlin]
----
// Create a write-and-review workflow with a feedback loop
fun createWriteAndReviewWorkflow(): AgentScope {
    return RepeatUntilBuilder
        .returning(ReviewedStory::class.java)       // <1>
        .consuming(UserInput::class.java)
        .withMaxIterations(5)                       // <2>
        .repeating { ctx ->                         // <3>
            val story = Story("A story about: ${ctx.input.content} (iteration ${ctx.iteration})")
            val feedback = HumanFeedback(
                approved = ctx.iteration >= 2,
                comments = if (ctx.iteration >= 2) "Excellent!" else "Keep improving"
            )
            ReviewedStory(story, feedback)
        }
        .until { ctx ->                             // <4>
            ctx.lastResult?.feedback?.approved == true
        }
        .build()
        .build()
}
----

<1> Specify the result type for the loop
<2> Set maximum iterations to prevent infinite loops
<3> Define the task that runs on each iteration
<4> Define the acceptance criteria - loop ends when this returns `true`

====== Programmatic Agent Detection

The `FlowNestingManager` detects programmatic agents via the `AgentScope` interface:

[cols="1,2,2",options="header"]
|===
|Type |GOAP Support |Utility Support

|`AgentScope` with single goal
|Yes - output type inferred from goal
|Yes

|`AgentScope` with multiple goals
|No - ambiguous output type
|Yes

|`core.Agent` (implements `AgentScope`)
|Same rules as `AgentScope`
|Same rules as `AgentScope`
|===

====== Using the Kotlin DSL

The most idiomatic Kotlin approach uses the `agent {}` DSL, which provides a clean, type-safe way to define agents:

[source,kotlin]
----
import com.embabel.agent.api.dsl.agent

// Create an agent using the Kotlin DSL
fun createProcessorWithDsl(): Agent {
    return agent(
        name = "ProcessorAgent",
        description = "Process data using Kotlin DSL",
    ) {
        transformation<UserInput, ProcessedData>(  // <1>
            name = "process",
            description = "Process user input",
        ) {
            ProcessedData("processed: ${it.input.content}")
        }

        goal(                                      // <2>
            name = "ProcessedData",
            description = "Data has been processed",
            satisfiedBy = ProcessedData::class,
        )
    }
}
----

<1> Define actions with `transformation<Input, Output>` using reified generics
<2> Define goals with the `goal()` function

The Kotlin DSL provides type-safe, concise agent definitions that integrate naturally with Kotlin codebases.

====== Multi-Action Agents with the Kotlin DSL

The DSL supports multiple actions, conditions, and goals:

[source,kotlin]
----
fun createMultiActionAgent(): Agent {
    return agent(
        name = "MultiStepProcessor",
        description = "Process data in multiple steps",
    ) {
        // First transformation: UserInput -> Story
        transformation<UserInput, Story>(
            name = "writeStory",
            description = "Write a story from user input",
        ) {
            Story("A story about: ${it.input.content}")
        }

        // Second transformation: Story -> ReviewedStory
        transformation<Story, ReviewedStory>(
            name = "reviewStory",
            description = "Review the story",
        ) {
            ReviewedStory(it.input, HumanFeedback(approved = true, comments = "Looks good!"))
        }

        // Goal: defines what we're trying to achieve
        goal(
            name = "ReviewedStory",
            description = "A reviewed story",
            satisfiedBy = ReviewedStory::class,
        )
    }
}
----

====== Agents with LLM-Powered Actions

The Kotlin DSL also supports LLM-powered transformations:

[source,kotlin]
----
fun createLlmPoweredAgent(): Agent {
    return agent(
        name = "LlmProcessor",
        description = "Process data with LLM",
    ) {
        // LLM-powered transformation
        promptedTransformer<UserInput, Summary>(
            name = "summarize",
            description = "Summarize the input",
            llm = LlmOptions(temperature = 0.7),
        ) { ctx ->
            "Summarize this text: ${ctx.input.content}"
        }

        goal(
            name = "Summary",
            description = "A summary of the input",
            satisfiedBy = Summary::class,
        )
    }
}
----

====== Returning DSL-Created Agents from Actions

DSL-created agents can be returned from actions to run as nested agents:

[source,kotlin]
----
@Agent(description = "Orchestrator that delegates to DSL agents")
class OrchestratorAgent {

    @Action
    @AchievesGoal(description = "Process via delegated DSL agent")
    fun process(input: UserInput): Agent {  // <1>
        return agent(                        // <2>
            name = "DynamicProcessor",
            description = "Dynamically created processor",
        ) {
            transformation<UserInput, ProcessedData>(
                name = "process",
                description = "Process the input",
            ) {
                ProcessedData("dynamically processed: ${it.input.content}")
            }

            goal(
                name = "ProcessedData",
                description = "Data processed",
                satisfiedBy = ProcessedData::class,
            )
        }
    }
}
----

<1> Return `Agent` (which implements `AgentScope`) from an action
<2> Create the agent dynamically using the DSL

This pattern enables powerful dynamic agent composition where the nested agent's structure is determined at runtime.

====== Use Cases for Programmatic Agents

Programmatic agents are useful when:

* *Dynamic composition*: The nested agent's structure depends on runtime conditions
* *Factory patterns*: Creating specialized agents based on input characteristics
* *DSL-based workflows*: Using `SimpleAgentBuilder`, `RepeatUntilBuilder`, or `agent {}` DSL
* *Testing*: Creating lightweight agents for test scenarios without annotations
