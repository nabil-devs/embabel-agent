[[reference.annotations]]
=== Annotation model

Embabel provides a Spring-style annotation model to define agents, actions, goals, and conditions.
This is the recommended model to use in Java, and remains compelling in Kotlin.

==== The `@Agent` annotation

This annotation is used on a class to define an agent.
It is a Spring stereotype annotation, so it triggers Spring component scanning.
Your agent class will automatically be registered as a Spring bean.
It will also be registered with the agent framework, so it can be used in agent processes.

You must provide the `description` parameter, which is a human-readable description of the agent.
This is particularly important as it may be used by the LLM in agent selection.

==== The `@Subflow` annotation

The `@Subflow` annotation marks a class that can be returned from an action to enter a nested workflow. Unlike `@Agent`, it is not a Spring stereotype and does not trigger component scanning.

Use `@Subflow` when you want to:

* Create nested workflows within an agent
* Define distinct phases or states in a multi-step process
* Encapsulate related actions that produce a specific output

IMPORTANT: For GOAP planning, a `@Subflow` class must define exactly one goal using either `@Action(goal = "...")` or `@AchievesGoal`. This tells the planner what type the subflow produces. Without a goal, GOAP cannot determine the output type and will fail to plan.

Example:

[source,kotlin]
----
@Agent(description = "Agent with nested subflow")
class MyAgent {

    @Action
    fun start(input: UserInput): ProcessingPhase {
        return ProcessingPhase(input.content)
    }

    @Subflow
    class ProcessingPhase(val data: String) {

        @Action(goal = "Process data into result")  // Required for GOAP!
        fun process(): Result {
            return Result(data.uppercase())
        }
    }

    @Action(goal = "Complete the workflow")
    fun complete(result: Result): FinalOutput {
        return FinalOutput(result.value)
    }
}
----

See <<reference.planners__workflows,Nested Workflows>> for more details on how subflows work with different planners.

==== The `@Action` annotation

The `@Action` annotation is used to mark methods that perform actions within an agent.

Action metadata can be specified on the annotation, including:

- `description`: A human-readable description of the action.
- `goal`: If set, indicates this action achieves a goal with this description. This is a shorthand for adding `@AchievesGoal(description="...")`. See <<Defining goals on actions>> for details.
- `pre`: A list of preconditions _additional to the input types_ that must be satisfied before the action can be executed.
- `post`: A list of postconditions _additional to the output type(s)_ that may be satisfied after the action is executed.
- `canRerun`: A boolean indicating whether the action can be rerun if it has already been executed.
Defaults to false.
- `cost`:Relative cost of the action from 0-1. Defaults to 0.0.
- `value`: Relative value of performing the action from 0-1. Defaults to 0.0.
- `toolGroups`: Named tool groups the action requires.
- `toolGroupRequirements`: Tool group requirements with QoS constraints.

//TODO: (jasper notes) Provide links to detailed docs for pre, post, canRerun, cost, etc. Also brief code example is useful here.

==== The `@Condition` annotation

The `@Condition` annotation is used to mark methods that evaluate conditions.
They can take an `OperationContext` parameter to access the blackboard and other infrastructure.
If they take domain object parameters, the condition will automatically be false until suitable instances are available.

> Condition methods should not have side effects--for example, on the blackboard.
This is important because they may be called multiple times.

//TODO (jasper notes) Provide a simple illustrative example with story-telling and supporting code example.

> Both Action and Condition methods may be inherited from superclasses. That is, annotated methods on superclasses will be treated as actions on a subclass instance.

> Give your Action and Condition methods unique names, so the planner can distinguish between them.

==== Parameters

`@Action` methods must have at least one parameter.
`@Condition` methods must have zero or more parameters, but otherwise follow the same rules as `@Action` methods regarding parameters.
Ordering of parameters is not important.

Parameters fall in two categories:

* _Domain objects_.
These are the normal inputs for action methods.
They are backed by the blackboard and will be used as inputs to the action method.
A nullable domain object parameter will be populated if it is non-null on the blackboard.
This enables nice-to-have parameters that are not required for the action to run.
In Kotlin, use a nullable parameter with `?`: in Java, mark the parameter with the `org.springframework.lang.Nullable` or another `Nullable` annotation.

* _Infrastructure parameters_, such as the `OperationContext`, `ProcessContext`, and `Ai` may be used in action or condition methods.

NOTE: Domain objects drive planning, specifying the preconditions to an action.

The `ActionContext` or `ExecutingOperationContext` subtype can be used in action methods.
It adds `asSubProcess` methods that can be used to run other agents in subprocesses.
This is an important element of composition.

> Use the least specific type possible for parameters.
Use `OperationContext` unless you are creating a subprocess.

===== Custom Parameters

Besides two default parameter categories described above, you can provide your own parameters by implementing the `ActionMethodArgumentResolver` interface.
The two main methods of this interface are:

* `supportsParameter`, which indicates what kind of parameters are supported, and
* `resolveArgument`, which resolves the argument into an object used to invoke the action method.

NOTE: Note the similarity with Spring MVC, where you can provide custom parameters by implementing a `HandlerMethodArgumentResolver`.

> All default parameters are provided by `ActionMethodArgumentResolver` implementations.

To register your custom argument resolver, provide it to the `DefaultActionMethodManager` component in your Spring configuration.
Typically, you will register (some of) the defaults as well your custom resolver, in order to support the default parameters.

TIP: Make sure to register the `BlackboardArgumentResolver` as last resolver, to ensure that others take precedence.

==== Binding by name

The `@RequireNameMatch` annotation can be used to <<reference.flow__binding, bind parameters by name>>.

//TODO: (jasper notes) Provide an illustrative code example here.

==== Handling of return types

Action methods normally return a single domain object.

Nullable return types are allowed.
Returning null will trigger replanning.
There may or not be an alternative path from that point, but it won't be what the planner
was previously trying to achieve.

//TODO: (jasper notes) A diagram showing this would be super cool here.

There is a special case where the return type can essentially be a union type, where the action method can return one ore more of several types.
This is achieved by a return type implementing the `SomeOf` tag interface.
Implementations of this interface can have multiple nullable fields.
Any non-null values will be bound to the blackboard, and the postconditions of the action will include all possible fields of the return type.

For example:

[source,kotlin]
----
// Must implement the SomeOf interface
data class FrogOrDog(
    val frog: Frog? = null,
    val dog: Dog? = null,
) : SomeOf

@Agent(description = "Illustrates use of the SomeOf interface")
class ReturnsFrogOrDog {

    @Action
    fun frogOrDog(): FrogOrDog {
        return FrogOrDog(frog = Frog("Kermit"))
    }

    // This works because the frog field of the return type was set
    @AchievesGoal(description = "Create a prince from a frog")
    @Action
    fun toPerson(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }
}
----

This enables routing scenarios in an elegant manner.

TIP: Multiple fields of the `SomeOf` instance may be non-null and this is not an error.
It may enable the most appropriate routing.

Routing can also be achieved via subtypes, as in the following example:

[source,kotlin]
----
@Action
fun classifyIntent(userInput: UserInput): Intent? = // <1>
    when (userInput.content) {
        "billing" -> BillingIntent()
        "sales" -> SalesIntent()
        "service" -> ServiceIntent()
        else -> {
            loggerFor<IntentReceptionAgent>().warn("Unknown intent: $userInput")
            null
        }
    }

@Action
fun billingAction(intent: BillingIntent): IntentClassificationSuccess { // <2>
    return IntentClassificationSuccess("billing")
}

@Action
fun salesAction(intent: SalesIntent): IntentClassificationSuccess {
    return IntentClassificationSuccess("sales")
}

// ...
----

<1> Classification action returns supertype `Intent`. Real classification would likely use an LLM.
<2> `billingAction` and other action methods takes a subtype of `Intent`, so will only be invoked if the classification action returned that subtype.


==== Action method implementation

Embabel makes it easy to seamlessly integrate LLM invocation and application code, using common types.
An `@Action` method is a normal method, and can use any libraries or frameworks you like.

The only special thing about it is its ability to use the `OperationContext` parameter to access the blackboard and invoke LLMs.

==== Defining goals on actions

Actions can define goals using the `goal` parameter on `@Action`, or by adding a separate `@AchievesGoal` annotation.

===== Using `@Action(goal="...")`

The simplest way to indicate that an action achieves a goal is using the `goal` parameter:

[source,kotlin]
----
@Action(goal = "Create a person from user input")
fun toPerson(userInput: UserInput): Person {
    return Person(userInput.content)
}
----

The `goal` parameter sets the goal description. If you also provide a `description` parameter, it applies only to the action itself, while `goal` defines the goal that completing this action achieves.

===== Using `@AchievesGoal`

For more advanced cases, you can use the `@AchievesGoal` annotation separately. This provides additional options like export settings and goal value:

[source,kotlin]
----
@AchievesGoal(
    description = "Create a person from user input",
    value = 0.8,                    // Goal value for utility-based planning
    export = ExportGoal(remote = true)  // Export goal for MCP
)
@Action
fun toPerson(userInput: UserInput): Person {
    return Person(userInput.content)
}
----

TIP: Use `@Action(goal="...")` for simple cases. Use `@AchievesGoal` when you need export settings, goal values, or other advanced configuration.

NOTE: If both `@AchievesGoal` and `@Action(goal="...")` are present, `@AchievesGoal` takes precedence.

==== Implementing the `StuckHandler` interface

If an annotated agent class implements the `StuckHandler` interface, it can handle situations where an action is stuck itself.
For example, it can add data to the blackboard.

//TODO: (japer notes) Provide concrete examples of when StuckHandler is useful.

Example:

[source,kotlin]
----
@Agent(
    description = "self unsticking agent",
)
class SelfUnstickingAgent : StuckHandler {

    // The agent will get stuck as there's no dog to convert to a frog
    @Action
    @AchievesGoal(description = "the big goal in the sky")
    fun toFrog(dog: Dog): Frog {
        return Frog(dog.name)
    }

    // This method will be called when the agent is stuck
    override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
        called = true
        agentProcess.addObject(Dog("Duke"))
        return StuckHandlerResult(
            message = "Unsticking myself",
            handler = this,
            code = StuckHandlingResultCode.REPLAN,
            agentProcess = agentProcess,
        )
    }
}
----

==== Advanced Usage: Nested processes

An `@Action` method can invoke another agent process.
This is often done to use a stereotyped process that is composed using the DSL.

Use the `ActionContext.asSubProcess` method to create a sub-process from the action context.

For example:

[source,kotlin]
----
@Action
fun report(
    reportRequest: ReportRequest,
    context: ActionContext,
): ScoredResult<Report, SimpleFeedback> = context.asSubProcess(
    // Will create an agent sub process with strong typing
    EvaluatorOptimizer.generateUntilAcceptable(
        maxIterations = 5,
        generator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic, generate a detailed report in ${reportRequest.words} words.

        # Topic
        ${reportRequest.topic}

        # Feedback
        ${it.input ?: "No feedback provided"}
                """.trimIndent()
            )
        },
        evaluator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic and word count, evaluate the report and provide feedback
        Feedback must be a score between 0 and 1, where 1 is perfect.

        # Report
        ${it.input.report}

        # Report request:

        ${reportRequest.topic}
        Word count: ${reportRequest.words}
        """.trimIndent()
            )
        },
    ))
----

